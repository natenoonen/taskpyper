#!/usr/bin/env python

""" taskpyper is a module of taskaper markup tools written in pthon."""

import re;
from optparse import OptionParser;
from sys import stdout,stderr
from datetime import datetime

__version__  = u"0.1.0.12"
gDebug = True;


en_isoOffsetNames = {-1:"yesterday",0:"today",1:"tomorrow"}
#this week, next week, etc is harder



#:todo: hide this function from the outside world
def debugprint(*stuffToPrint):
	#Astric indicates that it can handle a list as input
	if (gDebug):
		print "DEBUG:" + " ".join(stuffToPrint)


class TaskBlob():
	""" TaskBlob is a class that contains a text file of tasks
	and accessory functions.
	TODO:
	"""
	tasksRawText = None;
	sourceFilename = None;

	def __init__(self,filename=None):
		self.load(filename)

	def load(self,filename):
		debugprint( 'creating task blob from %s' %filename)
		if filename is not None:
			debugprint('Loading from file %(file)s' % {'file': filename})
			fh = open(filename,'r')
			if(fh):
				self.tasksRawText = fh.read()	
				fh.close()
				self.sourceFilename = filename
				print 'load file OK'	
		else: #if filename is None
			print 'No file to load'
			self.tasksRawText = None;
		
		if self.tasksRawText is not None :
			#parse/built it out
			debugprint( 'reading tasks from list')
			taskReg = re.compile(u"\s*- .*\n")
			taskIter = taskReg.finditer(self.tasksRawText)
				

	def autobackup(self, backupFilename=None):
		"""backup the taskpaper we have to a given name, or
		if no name is given, backup to an name autogenerated by the 
		time the funciton is called"""
		if backupFilename is None:
			now = datetime.now()
			nowTxt = now.strftime("%Y.%m.%d.%H.%M.%S")
			backFilename = self.sourceFilename + "." + nowTxt +".backup"
			debugprint("autobackup filename" + backFilename)
			fh = open(backFilename,"w+")
			fh.write(self.tasksRawText)
			fh.close();
			del fh;

	def removeExactMatch(self,exactTaskText):
		if exactTaskText:
			if exactTaskText[-1] != '\n':
				exactTaskText = exactTaskText + '\n'
			reg = re.compile(exactTaskText);
			reg.search(tasksRawText);
			print "Function not FINISHED"
			
		else:
			print "no text FAIL!"
		#make sure we have an exact whole line match
		#and nuke it from the lastRawRead
		#tpBlob.removeExactMatch(taskMatches[0])


	def findTaskByMatching(self,taskTextToFind):
		"""Takes a string, tries to find all tasks that have that text in it, and
		then returns an array of all tasks that matched the line"""
		debugprint( 'find task by text: %s' % taskTextToFind)
		matchedLines = []
		matchReg = re.compile(re.escape(taskTextToFind), re.I)
		for x in self.tasksRawText.split('\n'):
			if (matchReg.search(x) != None):
				matchedLines.append(x)
				
		return matchedLines

		

	def findDue(self, targetDT,skipDoneTasks=True, lang="EN"):
		""" This function scans for items due that match the @date
		with the ISO format date info matching the passed datetime (targetDT). 
		If the targetDT is the same day as the current system information, @today, @tonight and 
		other patterns are added to thet search."""
		duePatterns = ["\s@due\s","\s@todo"]		
		dueItems = []
		#ISO pattern xxx.xx.xx or xxxx-xx-xx
		todayDue = u"\s@due\(%(year)04d(-|.| )%(month)02d(-|.| )%(day)02d\)" %  \
					{'year':targetDT.year, 'month':targetDT.month, 'day':targetDT.day}
		duePatterns.append(todayDue)
			
		#if today is targetDT, add some extra patterns	
		now = datetime.now()
		if(targetDT.year == now.year and targetDT.month == now.month and targetDT.day == now.day):
			duePatterns.extend([u"\s@today",u"\s@tonight"])

		#local language pattern if we ahve it
		duePatterns.append(u"\s@" +now.strftime("%A")+u"\S") #full day name
		duePatterns.append(u"\s@" +now.strftime("%a")+u"\S") #abbr day name
		
		#if(isoWeekdaySets.has_key(lang)):
		#	weekdays = isoWeekdaySets[lang]
		#	if weekdays.has_key(now.isoweekday()) :
		#		str = u"\s@" + weekdays[now.isoweekday()];
		#		debugprint(str)
		#		duePatterns.append(str)
		#		*/

		#:TODO: if tomorrow is targetDT, add some extra patterns	
			
		#:TODO: if yesterday was targetDT, add some extra patterns	


		#serch for the matches
		for task in self.tasksRawText.split('\n'):
			negatorPattern = u"\s@done"
			negatorReg = re.compile(negatorPattern)
			#TODO add ability to grab 'sub-issues'
			for pattern in duePatterns:
				#print '  doing pattern %s' % pattern
				dueReg = re.compile(pattern, re.I);
				if(dueReg.search(task)):
					if((skipDoneTasks == False) or (negatorReg.search(task) == None) ):
						dueItems.append(task);
						#prevIssueIndentLvl = X;
						debugprint('due item found: %s' % task)
		return dueItems;

	def findPastDue(self):
		#import datetime;
		#today = datetime.date.today()
		dueWithDate = [];
		for x in self.tasksRawText.split('\n'):
			pastDueReg = re.compile(u"\s@due\([0-9]{4}-[0-9]{2}-[0-9]{2}\)");
			if(pastDueReg.search(x)):
				dueWithDate.append(x)
				#print 'due found %s' % x

	def setIsoDates( baseDateTime = datetime.now()):
		"""This funciton scans the file for  all dates with @somedayname and 
		converts them to @event(IsoDate) or @due (IsoDate)
		"""
		
		debugprint("Boo")
		
	
#	def updateAutomatics(self):
#		print "Testing UpdateAutomatics"
#		x = self.findAutomatics()

#	def findAutomatics(self):
#		"""returns a list of automated items from the raw text"""
#		matchAutomatedTag = []
#		for x in self.tasksRawText.split('n'):
#			print 'bar'
#			autoReg = re.compile(ur"@auto",re.I);
#			z = autoReg.search(x)
#			print z
#			if(z):
#				print 'baz'
#				print 'automated item found %s' % x
#				for c in range(0,len(z.groups())) :
				
#					print "Groups %d: %s " % c, z.groups(c) 
#				matchAutomatedTag.append(x)
#		return matchAutomatedTag

